import express from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { storageService } from '../services/storageService';
import { protect, AuthenticatedRequest } from '../middleware/authMiddleware';
import { RoleEnum, users } from '@/shared/schema'; // Assuming RoleEnum is exported from your schema
import { db } from '../db/drizzle'; // For direct DB access if needed for specific checks
import { eq } from 'drizzle-orm';


const router = express.Router();

const JWT_SECRET = process.env.JWT_SECRET || 'your-very-strong-secret-key-32-chars';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1d'; // 1 day

// --- Helper to generate JWT and set cookie ---
const generateTokenAndSetCookie = (res: express.Response, userId: string) => {
  const token = jwt.sign({ id: userId }, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // Use secure cookies in production
    sameSite: 'strict', // Mitigate CSRF
    maxAge: 24 * 60 * 60 * 1000, // 1 day in milliseconds (should match JWT_EXPIRES_IN)
  });
  return token;
};

// --- Register a new user ---
// POST /api/auth/register
router.post('/register', async (req, res) => {
  const { name, email, password, role = RoleEnum.Tecnico } = req.body;

  if (!name || !email || !password) {
    return res.status(400).json({ message: 'Please provide name, email, and password' });
  }

  try {
    const existingUser = await storageService.getUserByUsername(email);
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists with this email' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const newUser = await storageService.createUser({
      name,
      email,
      passwordHash: hashedPassword,
      role: role as RoleEnum, // Ensure role is a valid RoleEnum value
      // id: nanoid() // if using nanoid for IDs and not auto-generated by DB
    });

    if (newUser) {
      generateTokenAndSetCookie(res, newUser.id); // Generate token and set cookie
      res.status(201).json({
        id: newUser.id,
        name: newUser.name,
        email: newUser.email,
        role: newUser.role,
      });
    } else {
      res.status(400).json({ message: 'Invalid user data' });
    }
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ message: 'Server error during registration' });
  }
});

// --- Authenticate user and get token (Login) ---
// POST /api/auth/login
router.post('/login', async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ message: 'Please provide email and password' });
  }

  try {
    // Check for demo users first (as per existing client logic)
    const demoUsers = [
      { id: 'demo-tecnico', email: 'tecnico@brasilit.com.br', password: '123456', name: 'TÃ©cnico Demo', role: RoleEnum.Tecnico },
      { id: 'demo-gestor', email: 'gestor@brasilit.com.br', password: '123456', name: 'Gestor Demo', role: RoleEnum.Gestor },
      { id: 'demo-admin', email: 'admin@brasilit.com.br', password: '123456', name: 'Admin Demo', role: RoleEnum.Admin },
    ];
    const demoUser = demoUsers.find(u => u.email === email && u.password === password);

    if (demoUser) {
      generateTokenAndSetCookie(res, demoUser.id);
      return res.json({
        id: demoUser.id,
        name: demoUser.name,
        email: demoUser.email,
        role: demoUser.role,
      });
    }

    const user = await storageService.getUserByUsername(email);

    if (user && user.passwordHash && (await bcrypt.compare(password, user.passwordHash))) {
      generateTokenAndSetCookie(res, user.id); // Generate token and set cookie
      res.json({
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
      });
    } else {
      res.status(401).json({ message: 'Invalid email or password' });
    }
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error during login' });
  }
});

// --- Get current logged-in user ---
// GET /api/auth/me
router.get('/me', protect, async (req: AuthenticatedRequest, res) => {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authorized, user data missing from request' });
  }
  try {
    // Fetch full user details using the ID from the token (req.user.id)
    // The 'protect' middleware currently only attaches the ID.
    const user = await db.query.users.findFirst({
        where: eq(users.id, req.user.id),
        columns: { // Explicitly exclude passwordHash
            id: true,
            name: true,
            email: true,
            role: true,
            createdAt: true,
            updatedAt: true,
        }
    });

    if (user) {
      res.json(user);
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error('Error fetching current user:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// --- Logout user ---
// POST /api/auth/logout
router.post('/logout', (req, res) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0), // Set cookie to expire immediately
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
  });
  res.status(200).json({ message: 'Logged out successfully' });
});

export default router;
